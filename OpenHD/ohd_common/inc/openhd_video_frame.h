/******************************************************************************
 * OpenHD
 *
 * Licensed under the GNU General Public License (GPL) Version 3.
 *
 * This software is provided "as-is," without warranty of any kind, express or
 * implied, including but not limited to the warranties of merchantability,
 * fitness for a particular purpose, and non-infringement. For details, see the
 * full license in the LICENSE file provided with this source code.
 *
 * Non-Military Use Only:
 * This software and its associated components are explicitly intended for
 * civilian and non-military purposes. Use in any military or defense
 * applications is strictly prohibited unless explicitly and individually
 * licensed otherwise by the OpenHD Team.
 *
 * Contributors:
 * A full list of contributors can be found at the OpenHD GitHub repository:
 * https://github.com/OpenHD
 *
 * © OpenHD, All Rights Reserved.
 ******************************************************************************/

#ifndef OPENHD_OPENHD_OHD_COMMON_OPENHD_VIDEO_FRAME_H_
#define OPENHD_OPENHD_OHD_COMMON_OPENHD_VIDEO_FRAME_H_

#include <chrono>
#include <memory>
#include <sstream>
#include <vector>

namespace openhd {

// R.n this is the best name i can come up with
// This is not required to be exactly one frame, but should be
// already packetized into rtp fragments
// R.n it is always either h264,h265 or mjpeg fragmented using the RTP protocol
// R.n 这是我能想出的最佳名称
// 这不需要严格是一个帧，但应该已经按照RTP协议分段成RTP片段
// R.n 它始终是h264、h265或mjpeg，并使用RTP协议进行分段
struct FragmentedVideoFrame {
  std::vector<std::shared_ptr<std::vector<uint8_t>>> rtp_fragments;

  // Time point of when this frame was produced, as early as possible.
  // ideally, this would be the time point when the frame was generated by the
  // CMOS - but r.n no platform supports measurements this deep.
  // 该帧生成的时间点，尽可能早。
  // 理想情况下，这应是帧由CMOS生成的时间点，
  // 但R.n 没有平台支持如此深入的测量。
  std::chrono::steady_clock::time_point creation_time =
      std::chrono::steady_clock::now();

  // OpenHD WB supprts changing encryption on the fly - and r.n no other
  // implementation exists. For the future: This hints that the link
  // implementation should encrypt the data as secure as possible even though
  // that might result in higher CPU load.
  // OpenHD WB 支持动态更改加密 - 目前没有其他实现。
  // 未来：这表明链路实现应尽可能安全地加密数据，尽管这可能会导致更高的CPU负载。
  bool enable_ultra_secure_encryption = false;
  std::shared_ptr<std::vector<uint8_t>> dirty_frame = nullptr;  // replaces fragments

  // Set to true if the stream is an intra stream
  // 如果流是内流，则设置为 true
  bool is_intra_stream = false;

  // Set to true if this frame is an IDR frame and therefore we can safely drop
  // previous frame(s) without having complete corruption
  // 如果该帧是IDR帧，则设置为 true，因此我们可以安全地丢弃
  // 之前的帧，而不会导致完全的损坏。
  bool is_idr_frame = false;
  std::string to_string() const {
    int total_bytes = 0;
    for (auto& fragment : rtp_fragments) total_bytes += fragment->size();
    if (dirty_frame) total_bytes += dirty_frame->size();
    std::stringstream ss;
    ss << "Bytes:" << total_bytes << " Fragments:" << rtp_fragments.size();
    ss << " IDR:" << (is_idr_frame ? "Y" : "N");
    return ss.str();
  }
};
typedef std::function<void(int stream_index, const openhd::FragmentedVideoFrame&
                                                 fragmented_video_frame)>
    ON_ENCODE_FRAME_CB;

struct AudioPacket {
  std::shared_ptr<std::vector<uint8_t>> data;
};
typedef std::function<void(const openhd::AudioPacket& audio_packet)>
    ON_AUDIO_TX_DATA_PACKET;

}  // namespace openhd
#endif  // OPENHD_OPENHD_OHD_COMMON_OPENHD_VIDEO_FRAME_H_
