/******************************************************************************
 * OpenHD
 *
 * Licensed under the GNU General Public License (GPL) Version 3.
 *
 * This software is provided "as-is," without warranty of any kind, express or
 * implied, including but not limited to the warranties of merchantability,
 * fitness for a particular purpose, and non-infringement. For details, see the
 * full license in the LICENSE file provided with this source code.
 *
 * Non-Military Use Only:
 * This software and its associated components are explicitly intended for
 * civilian and non-military purposes. Use in any military or defense
 * applications is strictly prohibited unless explicitly and individually
 * licensed otherwise by the OpenHD Team.
 *
 * Contributors:
 * A full list of contributors can be found at the OpenHD GitHub repository:
 * https://github.com/OpenHD
 *
 * © OpenHD, All Rights Reserved.
 ******************************************************************************/

#ifndef XMAVLINKSERVICE_MAV_INCLUDE_H
#define XMAVLINKSERVICE_MAV_INCLUDE_H

extern "C" {
// NOTE: Make sure to include the openhd mavlink flavour, otherwise the custom
// messages won't bw parsed.
#include <openhd/mavlink.h>
}

#include <chrono>
#include <functional>
#include <memory>
#include <vector>

// OpenHD mavlink sys IDs
// Any mavlink message generated by openhd on the ground unit uses this sys id
// OpenHD 的 MAVLink 系统 ID
// 地面单元上由 OpenHD 生成的任何 MAVLink 消息都使用此系统 ID。
static constexpr auto OHD_SYS_ID_GROUND = 100;

// Any mavlink message generated by openhd on the air unit uses this sys id
static constexpr auto OHD_SYS_ID_AIR = 101;
static_assert(OHD_SYS_ID_GROUND != OHD_SYS_ID_AIR);

// Sys id of QOpenHD or any other gcs connected to the ground unit that talks
// mavlink
// QOpenHD 或任何其他连接到地面单元并支持 MAVLink 的地面控制站（GCS）的系统 ID。
static constexpr auto QOPENHD_SYS_ID = 255;

// dirty (hard coded for now). Pretty much all FCs default to a sys id of 1 -
// this works as long as long as the user doesn't change the sys id
// 临时方案（目前是硬编码的）。几乎所有的飞控默认系统 ID 为 1——
// 只要用户不更改系统 ID，这种方式就可以正常工作。
static constexpr auto OHD_SYS_ID_FC = 1;
static constexpr auto OHD_SYS_ID_FC_BETAFLIGHT = 0;

static constexpr auto OHD_GROUND_CLIENT_UDP_PORT_OUT = 14550;
static constexpr auto OHD_GROUND_CLIENT_UDP_PORT_IN = 14551;

struct MavlinkMessage {
    // mavlink_message_t，这是 MAVLink 协议中使用的基础消息结构
    mavlink_message_t m{};
    // how often this packet should be injected (increase reliability)
    // 此数据包应被注入的频率（用于提高可靠性）。
    int recommended_n_injections = 1;
    [[nodiscard]] std::vector<uint8_t> pack() const {
        std::vector<uint8_t> buf(MAVLINK_MAX_PACKET_LEN);
        // 使用 mavlink_msg_to_send_buffer 函数将 m 对象（即 MAVLink 消息）序列化为一个字节数组。
        auto size = mavlink_msg_to_send_buffer(buf.data(), &m);
        buf.resize(size);
        return buf;
    }
};

struct AggregatedMavlinkPacket {
    std::shared_ptr<std::vector<uint8_t>> aggregated_data;
    int recommended_n_retransmissions = 1;  // 这是一个整数，指定在数据包传输失败的情况下，应该重新传输多少次。默认值为 1，即如果传输失败会尝试重新传输一次。
    // how many mavlink packet(s) have been aggregated together
    // 这个整数用于记录有多少个单独的 MAVLink 数据包被聚合在一起，形成这个聚合数据包。聚合的目的是为了优化传输，减少开销，或将相关的消息捆绑在一起。
    int n_aggregated_mavlink_packets = 0;
};

/**
 * It is more efficient to aggregate / keep mavlink messages in chunks instead
 * of using a wb packet for each of them - Aggregates the given mavlink
 * message(s) int packets >=@param max_mtu The n of recommended retransmissions
 * is the highest recommended number of all aggregated mavlink messages.
 */
/**
 * 将 MAVLink 消息聚合或分块处理比为每条消息单独使用一个 wb 数据包更高效——
 * 将给定的 MAVLink 消息聚合到数据包中，数据包大小 >= @param max_mtu。
 * 推荐的重新传输次数是所有聚合的 MAVLink 消息中推荐次数最高的值。
 */
static std::vector<AggregatedMavlinkPacket> aggregate_pack_messages(const std::vector<MavlinkMessage>& messages, uint32_t max_mtu = 1024) {
    std::vector<AggregatedMavlinkPacket> ret;
    auto buff = std::make_shared<std::vector<uint8_t>>();
    buff->reserve(max_mtu);
    int recommended_n_retransmissions = 1;  // 用于跟踪所有聚合的消息中需要重传的最大次数。初始值为 1。
    int n_aggregated_mavlink_packets = 0;   // 用于计数当前聚合的数据包中有多少个 MAVLink 消息。
    for (const auto& msg : messages) {
        auto data = msg.pack();
        // 检查当前 buff 的大小加上 data 的大小是否超出最大传输单元（max_mtu）。
        if (buff->size() + data.size() <= max_mtu) {
            // we haven't reached MTU yet
            buff->insert(buff->end(), data.begin(), data.end());  // 将 data 数据加入到 buff 中
            n_aggregated_mavlink_packets++;                       // 增加聚合的数据包计数
            // 更新 recommended_n_retransmissions，以确保最大重传次数是合适的。
            if (msg.recommended_n_injections > recommended_n_retransmissions) {
                recommended_n_retransmissions = msg.recommended_n_injections;
            }
        } else {
            // MTU is reached or we need to allocate a new buffer
            // 先检查 buff 是否为空，如果 buff 不为空，将当前的聚合数据包（即 buff）加入到 ret 中。
            if (!buff->empty()) {
                ret.push_back({buff, recommended_n_retransmissions});
                // 重新分配一个新的 buff，并为它预留空间，再将当前消息的 data 插入到新 buff 中。
                buff = std::make_shared<std::vector<uint8_t>>();
                buff->reserve(max_mtu);
                recommended_n_retransmissions = 1;
                n_aggregated_mavlink_packets = 0;
            }
            buff->insert(buff->end(), data.begin(), data.end());
            n_aggregated_mavlink_packets++;
            if (msg.recommended_n_injections > recommended_n_retransmissions) {
                recommended_n_retransmissions = msg.recommended_n_injections;
            }
        }
    }
    if (!buff->empty()) {
        ret.push_back({buff, recommended_n_retransmissions});
    }
    return ret;
}

// 计算一个 std::vector<MavlinkMessage> 类型的消息列表总共占用的字节数（即消息的总大小）
static int get_size(const std::vector<MavlinkMessage>& messages) {
    int ret = 0;
    for (const auto& message : messages) {
        ret += message.pack().size();
    }
    return ret;
}

// For registering a callback that is called every time component X receives one
// or more mavlink messages
// 用于注册一个回调函数，该回调函数在组件 X 每次接收到一条或多条 MAVLink 消息时被调用。
typedef std::function<void(const std::vector<MavlinkMessage> messages)> MAV_MSG_CALLBACK;

static int64_t get_time_microseconds() {
    const auto time = std::chrono::steady_clock::now().time_since_epoch();
    return std::chrono::duration_cast<std::chrono::microseconds>(time).count();
}

#endif  // XMAVLINKSERVICE_MAV_INCLUDE_H
